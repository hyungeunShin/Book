# 01. 컴퓨터 내부의 언어 체계

## 언어란 무엇인가
모든 언어의 뜻은 기호의 집합으로 인코딩된다. 하지만 의미를 기호로 인코딩하는 것만으로는 충분하지 않다. 언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 한다.
동일한 기호를 구분할 수 있는 요소는 문맥뿐인데, 언제나 문맥을 명확히 식별할 수 있는 것은 아니다. 컴퓨터 언어에도 마찬가지 문제가 있다.

## 문자 언어
문자 언어는 기호를 나열한 것이다. 기호를 정해진 순서대로 나열하면 단어를 만들 수 있다. 기호나 조합은 무궁무진한 가능성이 있다.
<br><br>
다음과 같은 세 가지 구성요소가 문자 언어의 틀을 이루는데, 컴퓨터 언어에서도 마찬가지다.
- 기호가 들어갈 상자
- 상자에 들어갈 기호
- 상자의 순서

## 비트
자연어에서는 상자를 **문자**라고 부르고 컴퓨터에서는 **비트**라고 부른다. '**비트**'라는 단어는 2진법을 사용한다는 뜻의 '**바이너리**'<sup>binary</sup>와 숫자를 뜻하는 '**디지트**'<sup>digit</sup>가 기묘하게 합쳐진 말이다.
이 결합이 기묘한 이유는 '바이너리'라는 말은 두 가지 부분으로 이뤄진 어떤 대상을 뜻하고, '디지트'라는 말은 일상생활에서 쓰는 10진수를 표현하는 10가지 기호(0~9)를 뜻하기 때문이다.
<br>
비트는 2진법을 사용한다. 이는 비트 상자에는 모스 부호의 점(.)과 선(-)처럼 두 가지 기호 중 하나만 담을 수 있다는 듯이다. 기호라는 개념은 추상적인데 실제로는 기호가 무엇이든 관계없다. 꺼짐/켜짐일 수도 있고, 낮/밤일 수도 있으며, 쌀/보리 게임일 수도 있다. 하지만 중요한 점은 언어는 문맥 없이는 제대로 작동할 수 없다는 점이다.

## 논리 연산
비트 사용법 중 하나는 "날씨가 추운가?", "내 모자를 좋아하나?"와 같이 예/아니요 질문에 대한 답을 표현하는 것이다. 이때 '예'를 **참**<sup>true</sup>이라는 용어로 부르고, '아니요'를 **거짓**<sup>false</sup>이라는 용어로 부른다.
"파티 장소는 어디인가?"와 같은 질문은 예/아니요로 답할 수 없기 때문에 한 비트만으로는 표현할 수 없다.
<br>
자연어에서 여러 예/아니요 구절을 엮어서 한 문장으로 만드는 경우가 자주 있다. "밖에 비가 내리고 있거나 춥다면 코트를 입어라."라고 말할 수 있다. '비가 오고 있는가?'가 참이거나 '추운가?'가 참이거나 다른 비트들이 표현하는 내용으로부터
새로운 비트를 만들어내는 이런 동작을 **논리 연산**<sup>logic operation</sup>이라고 한다.

### 불리언 대수
대수가 수에 대한 연산 규칙의 집합인 것처럼, 1800년대 영국 수학자 조지 불<sup>George Boole</sup>이 만들어낸 **불리언 대수**<sup>Boolean algebra</sup>도 비트에 대해 사용할 수 있는 연산 규칙의 집합이다.
일반 대수와 마찬가지로 결합 법칙, 교환 법칙, 분배 법칙을 불리언 대수에 적용할 수 있다.
<br><br>
기본적인 불리언 연산자는 NOT, AND, OR 세 가지이다. 추가로 XOR이라는 합성 연산이 있다.
- **NOT:** 이 연산은 '논리적 반대'를 의미한다. 예를 들어, 거짓인 비트에 NOT을 하면 참이 되고 참인 비트에 NOT을 하면 거짓이 된다.
- **AND:** 이 연산은 둘 이상의 비트에 작용한다. 2비트 연산인 경우 첫 번째 비트가 참이고 두 번째 비트도 참인 경우에만 결과가 참이 된다. 2비트보다 더 많은 비트에 연산을 적용하는 경우 모든 비트가 참이면 AND 연산의 결과도 참이다.
- **OR:** 이 연산도 둘 이상의 비트에 작용한다. 2비트 연산인 경우 첫 번째 비트가 참이거나 두 번째 비트가 참이면 결과가 참이 된다. 2비트보다 더 많은 비트에 연산을 적용하는 경우 어느 한 비트라도 참이면 OR 연산의 결과도 참이다.
- **XOR:** 이 **배타적**<sup>exclusive</sup> OR의 결과는 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참이 된다. 즉, 두 값 중 어느 하나가 참이면 XOR도 참이지만 두 값이 모두 참이면 XOR의 결과는 거짓이다. 배타적 OR을 그대로 말로 하면 너무 길기 때문에 줄여서 XOR이라고 부른다.

### 드모르간의 법칙
1800년대 영국 수학자인 오거스터스 드모르간<sup>Augustus De Morgan</sup>은 불리언 대수에 적용할 수 있는 법칙을 추가로 알아냈다. 이 법칙은 발명자의 이름을 따서 **드모르간의 법칙**<sup>De Morgan's law</sup>이라고 알려져 있다. 이 법칙은
**a AND b**라는 연산은 <strong>NOT(NOT a OR NOT b)</strong>와 같다고 말한다. 이 말은 NOT을 사용하면 AND 연산을 OR 연산으로 대신할 수 있고 반대도 가능하다는 뜻이다. 컴퓨터에서 입력을 항상 원하는 형태로 얻을 수만은 없기 때문에 이런 성질이 유용할 때가 있다. 예를 들어, 입력이 '춥다'와 '비가 온다'라는 형식이라면 좋지만, 'NOT 춥다'와 'NOT 비가 온다'라는 형식일 수도 있기 때문이다.

## 정수를 비트로 표현하는 방법

### 양의 정수 표현
- 10진수<br>
우리는 보통 **10진수**<sup>decimal number</sup>체계를 사용하는데, 이는 우리의 손가락과 발가락이 10개씩이기 때문이다. 10진수 체계에서는 10가지 기호인 **숫자**<sup>digit</sup>를 상자에 담을 수 있다. 이때 오른쪽에서 왼쪽으로 상자가 쌓여가며, 각 상자마다 각기 다른 이름이 붙어 있다. 예를 들어 맨 오른쪽에 있는 상자에는 일의 자리, 오른쪽에서 두 번째 상자에는 십의 자리, 세 번째 상자는 백의 자리라는 이름이 붙는다. 각 이름은 10의 거듭제곱에 해당한다. 이 체계는 지수를 적용할 밑<sup>base</sup>으로 10을 사용하기 때문에 **밑이 10**인 시스템이라고 부른다.

- 2진수<br>
10진 숫자 대신 비트를 사용하기 때문에 각 상자에 사용할 수 있는 기호는 1과 0 두 가지밖에 없다. 기호가 10개인 10진수 체계에서 어떤 상자가 표현하는 값은 그 상자에 들어 있는 기호에 해당하는 값에 그 상자의 오른쪽 상자가 차지하는 자릿수에 10을 곱한 값을 곱한 것인데 2진수에서는 기호가 2개이기 때문에 각 상자는 자신의 오른쪽에 있는 상자의 자릿수에 2를 곱한 값의 자리를 표현한다. 각 상자의 자릿수는 2의 거듭제곱이며, 2진수 체계에서는 **2를 밑으로**하는 수 체계다.<br>
2진수에서 가장 오른쪽의 비트를 **가장 작은 유효 비트**<sup>least significant bit</sup>라고 부르고, 가장 왼쪽의 비트를 **가장 큰 유효 비트**<sup>most significant bit</sup>라고 부른다. 가장 작은 유효 비트와 가장 큰 유효 비트를 종종 세 글자 줄임말로 **LSB**와 **MSB**라고 부른다.

5028이라는 숫자를 10진수와 2진수로 표현하면
|$$10^3$$|$$10^2$$|$$10^1$$|$$10^0$$|
|--------|--------|--------|--------|
| 5      | 0      | 2      | 8      |

|$$2^{12}$$|$$2^{11}$$|$$2^{10}$$|$$2^9$$|$$2^8$$|$$2^7$$|$$2^6$$|$$2^5$$|$$2^4$$|$$2^3$$|$$2^2$$|$$2^1$$|$$2^0$$|
|----------|----------|----------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| 1        | 0        | 0        | 1     | 1     | 1     | 0     | 1     | 0     | 0     | 1     | 0     | 0     |

10진수로는 5,028이 네 자리 숫자라고 말할 수 있고 2진수로는 13비트 수가 된다고 말할 수 있다.

### 2진수 덧셈
10진 덧셈에서는 오른쪽(가장 작은 유효 숫자)에서 왼쪽으로 각 자리의 숫자를 서로 더한다. 결과가 9보다 크면 1을 올린다. 마찬가지로, 2진수에서도 각 비트를 LSB에서 MSB쪽으로 더하며 결과가 1보다 크면 1을 다음 자리(왼쪽)로 올린다.<br>
1 + 5 = 6을 2진수 덧셈으로 표현하면 1을 2진수로 표현하면 001이고 5를 2진수로 표현하면 101이다. 2진수 001과 101을 더하려면 가장 오른쪽 LSB부터 더하기를 시작한다. 가장 오른쪽 열의 2진수 1과 1을 더하면 2가 되지만 2진수에서는 2라는 기호가 없다. 대신 2가 실제로 2진수로 10이라는 것을 알고 있다. 따라서 합계로는 0을 표시하고 1을 다음(왼쪽) 숫자로 받아 올린다. 두 수 모두 중간의 비트가 0이기 때문에 여기서는 올려 받은 1만 합계로 적는다. 그 후 가장 왼쪽 열의 숫자를 더한다. 2진수에서 0 더하기 1은 1이다. 이렇게 최종 계산 결과는 110이고 10진수로 표현하면 6이 된다. 그리고 두 비트를 서로 더한 결과는 두 비트를 XOR 한 값고 같고, 올림은 두 비트를 AND 한 값과 같다.
<br>
우리가 접하는 **오버플로**<sup>overflow</sup>란 MSB에서 올림이 발생했다는 뜻이다. 예를 들어, 4비트 덧셈에서 1001(9)과 1000(8)을 더한 결과는 10001(17)이다. 하지만 MSB 왼쪽에 사용할 수 있는 비트가 없기 때문에 결과가 0001(1)이 된다.
컴퓨터에는 <strong>조건 코드(또는 상태코드) 레지스터</strong><sup>condition code register</sup>라는 것이 있어서 몇 가지 정보를 담아둔다. 이런 정보 중에는 **오버플로 비트**<sup>overflow bit</sup>가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. MSB 왼쪽에서 1을 빌려오는 경우는 **언더플로**<sup>underflow</sup>라고 부른다. 이에 해당하는 조건 코드도 컴퓨터에 들어있다.

### 음수 표현
4비트로는 0부터 15까지 16가지 수를 표현할 수 있다. 4비트로 수를 16가지만 표현할 수 있다는 말이 꼭 4비트로는 0부터 15까지만 표현할 수 있다는 뜻은 아니다. 언어는 문맥과 의미를 통해 작용한다. 이 말은 비트들을 해석하는 새로운 문맥을 만들 수 있다는 뜻이기도 하다.

#### 부호와 크기
음수와 양수를 구별하기 위해 흔히 **부호**<sup>sign</sup>를 사용한다. 부호에는 양(+)과 음(-)라는 두 가지 값이 있다. 따라서 이를 비트 하나를 써서 표현할 수 있다.<br>
예를 들어, 4비트를 우리는 가장 왼쪽 비트(MSB)를 부호에 사용하기로 멋대로 결정했다. 따라서 4비트 중에 3비트가 남고, 이를 사용하면 0부터 7까지 수를 표현할 수 있다. 부호 비트가 0이면 양수로 취급하고 부호 비트가 1이면 음수로 취급하자.
이로 인해 총 15가지 음수와 양수를 표현할 수 있다. 한 비트를 부호에 사용하고 나머지 비트를 수의 크기, 즉 0부터의 거리(절댓값)를 표현하기 위해 사용하는 이런 방법을 **부호와 크기**<sup>sign and magnitude</sup>표현법이라고 한다.
하지만 이 표현법은 두 가지 이유로 인해 널리 쓰이지 못한다.
- 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비된다.
- 부호와 크기 표현법을 사용하면 XOR과 AND를 통한 덧셈 계산이 불가능하다.

#### 1의 보수
음수를 표현하는 또 다른 방법으로는 양수의 모든 비트를 뒤집는 방법이 있다. 이런 방법을 **1의 보수**<sup>one's complement</sup>표현법이라고 부른다. 1의 보수 표현법에서도 부호와 크기 표현법과 비슷하게 비트들을 부호 비트와 나머지로 나눈다.
1의 보수라는 문맥에서는 NOT 연산을 통해 보수를 얻는다.

2진수 1의 보수 표현법
|부호|$$2^2$$|$$2^1$$|$$2^0$$|10진수|
|----|-------|-------|-------|------|
| 0  | 0     | 1     | 0     | +2   |
| 0  | 0     | 0     | 1     | +1   |
| 0  | 0     | 0     | 0     | +0   |
| 1  | 1     | 1     | 1     | -0   |
| 1  | 1     | 1     | 0     | -1   |
| 1  | 1     | 0     | 1     | -2   |

1의 보수 표현법에도 0을 두 가지 방식으로 표현한다는 문제가 여전히 존재한다. 게다가 1의 보수에서도 덧셈을 쉽게 할 수는 없다. 이 문제를 해결하려면 MSB 쪽에서 올림이 발생한 경우에는 LSB로 올림을 전달해야 하는데, 이를 **순환 올림**
<sup>end-around carry</sup>이라고 부른다. 1의 보수를 사용해 +2와 -1을 더하려면 0010과 1110의 뎃셈을 일반적인 덧셈처럼 계산하면 된다. MSB를 더하면 MSB 쪽에서 올림이 발생해 LSB로 올림을 전달해야 한다. 최종결과는 0000에 1을 더한 0001이 되고, 이 값은 실제로 +2와 -1을 더한 값과 같다.<br><br>
이 방식은 잘 작동하기는 하지만 순환 올림을 처리하기 위한 하드웨어를 추가해야 하기 때문에 좋은 해법은 아니다. 현대 컴퓨터에서는 부호와 크기 표현법이나 1의 보수 표현법을 모두 사용하지 않는다. 이 두 방식을 사용한 계산은 추가적인 하드웨어 없이는 제대로 작동할 수 없고, 하드웨어를 추가해야 한다는 말은 비용이 더 든다는 뜻이기 때문이다.

#### 2의 보수
어떤 수의 비트를 뒤집고(각 비트의 NOT을 취하고) 1을 추가하면 음수를 얻는다. 이때 MSB에서 올림이 발생하면 이 값은 버린다. 이런 방법을 **2의 보수**<sup>two's complement</sup>표현법이라고 부른다. 예를 들어, 0001(+1)의 비트를 뒤집으면 
1110이고, 여기에 1을 더하면 1111이 되며, 이 값이 -1을 표현한다. 비슷하게 0010(+2)를 뒤집으면 1101이며, 1을 더하면 1110이 되고 이 값이 -2를 표현한다.<br>
2의 보수에서는 0의 중복 표현 문제가 해결된다. 0000의 비트를 모두 뒤집으면 1111을 얻는다. 1111에 1을 더하면 [1]0000이 되는데 이 숫자는 5비트이므로 우리가 사용할 수 있는 4비트보다 크다. 따라서 1을 올림 비트로 생각하고 무시한다. 결과는 0000이 되는데 이 값은 처음에 시작한 0과 같다. 따라서 2의 보수 표현법에서는 0을 표현하는 방법은 하나뿐이다.

## 실수를 표현하는 방법
밑이 10인 실수에는 10진 소수점<sup>decimal point</sup>이 포함된다. 따라서 밑이 2인 경우, 실수를 표현하기 위해 2진 소수점을 표현할 방법이 필요하다. 여기서도 정수의 경우와 마찬가지로 문맥에 따라 실수를 표현하는 방법이 달라진다.

### 고정소수점 표현법
2진수를 사용해 소수를 표현하기 위해 2진 소수점의 위치를 임의로 정하는 방법이 있다. 예를 들어 4비트가 있다면 그 중 2비트는 2진 소수점의 오른쪽에 있는 분수들을 표현하는 데 쓰고, 2비트는 왼쪽에 있는 숫자들을 표현하는 데 쓸 수 있다. 소수점의 위치가 항상 일정하기 때문에 이런 방식을 **고정소수점**<sup>fixed-point</sup>표현법이라고 부른다.
<table>
  <tr>
    <td colspan="2">정수 부분</td>
    <td></td>
    <td colspan="2">분수 부분</td>
    <td>값</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>.</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>.</td>
    <td>0</td>
    <td>1</td>
    <td>$$\frac{1}{4}$$</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>.</td>
    <td>1</td>
    <td>0</td>
    <td>$$\frac{1}{2}$$</td>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>.</td>
    <td>1</td>
    <td>1</td>
    <td>$$\frac{3}{4}$$</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>.</td>
    <td>0</td>
    <td>1</td>
    <td>$$1 + \frac{1}{4}$$</td>
  </tr>
</table>
소수점 왼쪽의 정수 부분은 2진 표현법과 비슷하다. 한편 소수점 오른쪽의 2비트로도 네 가지 값을 표현할 수 있다. 다만 2진 소수점 오른쪽에 있는 숫자들은 10진 소수점의 오른쪽에 있는 숫자들과 비슷하게 분수를 표현한다. 차이점은 2진수의 경우에는 1/2, 1/4 등 2의 거듭제곱을 분모로 사용한다는 점이 다를 뿐이다. 이런 접근 방법이 잘 작동하기는 하지만, 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서 이런 방식을 사용하는 경우는 드물다.

### 부동소수점 표현법
이 문제를 해결하기 위해, 과학적 표기법을 2진수에 적용한다. 과학적 표기법은 수를 해석하는 새로운 방법을 도입해서 큰 범위의 수를 표현한다. 과학적 표기법에서는 10진 소수점 왼쪽이 한 자리뿐인 소수(이를 **가수**<sup>mantissa</sup>라 한다)에 10을 몇 번(이를 **지수**<sup>exponent</sup>라 한다) 거듭제곱한 값을 곱하는 방식으로 소수를 표현한다. 예를 들어 과학적 표기법에서는 0.0012 대신 $$1.2 \times 10^{-3}$$이라고 쓴다. 2진법으로 표기할 때는 10이 아닌 2를 밑으로 한다는 점만 다를 뿐이다. 따라서 가수 부분은 2진 소수, 지수 부분은 2의 거듭제곱 횟수를 표현한다.<br>
이런 표현법을 **부동소수점**<sup>floating-point</sup>표현법이라고 부른다.
<table>
  <tr>
    <td colspan="3">가수 부분</td>
    <td colspan="2">지수 부분</td>
    <td>값</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0($$0 \times 2^{0}$$)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>0($$0 \times 2^{1}$$)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>0($$0 \times 2^{2}$$)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0($$0 \times 2^{3}$$)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>0.5($$\frac{1}{2} \times 2^{0}$$)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1.0($$\frac{1}{2} \times 2^{1}$$)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>2.0($$\frac{1}{2} \times 2^{2}$$)</td>
  </tr>
  <tr>
    <td>0</td>
    <td>.</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>4.0($$\frac{1}{2} \times 2^{3}$$)</td>
  </tr>
</table>

이 예제는 단지 4비트만 사용하지만 부동소수점 표현법의 비효율성을 보여준다.
- 비트 조합 중에 낭비되는 부분이 많다.
- 비트 패턴이 가능한 모든 수를 표현하지는 못한다. 지수가 커질수록 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커진다.

### IEEE 부동소수점 수 표준
부동소수점 수 시스템은 컴퓨터에서 계산을 수행할 때 실수를 표현하는 표준 방법이다. 더 많은 비트를 사용하며 가수와 지수에 대해 각각 부호 비트를 사용한다. 다만 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다. 그리고 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하기 위한 여러 가지 트릭이 사용된다.<br><br>
똑같은 비트를 사용하더라도 정밀도<sup>precision</sup>를 가능한 한 높이고 싶다. 한 가지 트릭은 정규화<sup>normalization</sup>다. 정규화는 가수를 조정해서 맨 앞에 0이 없게 만드는 것이다. 이런 식으로 가수를 조정하려면 지수도 조정해야 한다. 두 번째 트릭은 디지털 이큅먼트 사<sup>Digital Equipment Corporation</sup>에서 고안한 것으로, 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략하는 것이다. 이로 인해 가수에 1비트를 더 사용할 수 있다.

두 가지 부동소수점 수가 존재한다.
- **기본 정밀도**<sup>single precision</sup><br>
기본 정밀도 수는 32비트를 사용하며 7비트 정밀도로 대략 $$\pm 10^{\pm 38}$$정도의 범위를 표현할 수 있다.
- **2배 정밀도**<sup>double precision</sup><br>
2배 정밀도 수는 64비트를 사용하며 15비트 정밀도로 대략 $$\pm 10^{\pm 308}$$정도의 범위를 표현할 수 있다.

## 2진수를 다루는 쉬운 방법

### 8진 표현법<sup>octal representation</sup>
8진이라는 말은 밑이 8이라는 뜻이다. 8진 표현법은 2진수 비트들을 3개씩 그룹으로 묶는 아이디어다.<br>
예를 들어 100101110001010100 이라는 2진수가 있다.
|100|101|110|001|010|100|
|---|---|---|---|---|---|
| 4 | 5 | 6 | 1 | 2 | 4 |

비트들을 3개씩 묶고, 각 그룹에 8진 숫자를 부여해 456124를 얻었다.

### 16진 표현법<sup>hexadecimal representation</sup>
요즘 컴퓨터는 8비트의 배수를 사용해 만들어지는데 8의 배수는 4(16진수 한 자리의 비트 수)로는 나눠지지만 3(8진수 한 자리의 비트 수)로는 균일하게 나눠지지 않기 때문에 8진수보다 16진수가 자주 사용된다.<br><br>
2진수를 표현하려면 두 가지 숫자만 있으면 되기 때문에 10진 숫자 기호 중에 2 가지(0과 1)를 2진수에 차용하기는 쉽다. 8진수의 경우에도 10개의 숫자 중 8개만 필요하다. 하지만 16진수 숫자 하나를 표현하려면 우리가 갖고 있는 10가지 숫자만으로는 충분하지 않다. 10부터 15까지의 숫자를 표현하기 위해 여섯 가지 숫자가 더 필요했고 abcdef로 표현하기로 했다.<br>
예를 들어 11010011111111000001 이라는 2진수가 있다.

|1101|0011|1111|1100|0001|
|----|----|----|----|----|
| d  | 3  | f  | c  | 1  |

비트를 4개씩 묶고, 각 그룹에 16개의 기호(0123456789abcdef) 중 한 값을 할당한다.

### 프로그래밍 언어의 진법 표기법
2진수를 다른 진수로 표현하는 규칙
- 0으로 시작하는 숫자는 8진 숫자이다. 예를 들어, 017은 8진수이며 값은 10진수로 15다.
- 1부터 9 사이의 숫자로 시작하는 숫자는 10진수다. 예를 들어, 123은 10진수다.
- 0x가 앞에 붙은 숫자는 16진수다. 예를 들어, 0x12f는 16진수이며 값은 10진수 303이다.

## 비트 그룹의 이름
비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어진다. 따라서 비트를 좀 더 큰 덩어리로 조직화해야 한다. 다양한 시도가 있었지만 시간이 지남에 따라 세계적으로 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 **바이트**<sup>byte</sup>라고 부른다.
|이름|비트 개수|
|----|---------|
|니블(nibble)|4|
|바이트(byte)|8|
|하프 워드(half word)|16|
|워드(word)|32|
|더블 워드(double word)|64|

|단위|바이트|
|----|------|
|킬로바이트|$$2^{10}$$|
|메가바이트|$$2^{20}$$|
|기가바이트|$$2^{30}$$|
|테라바이트|$$2^{40}$$|

## 텍스트 표현

### 아스키 코드
수와 마찬가지로 텍스트를 표현하는 방법의 경우에도 몇 가지 아이디어가 서로 경쟁했다. 1963년부터 승자는 **정보 교환을 위한 미국 표준 코드**<sup>ASCII, American Standard Code for Information Interchange</sup>였다. 아스키는 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당했다.

### 다른 표준의 진화
아스키는 영어를 표현하는 데 필요한 모든 문자를 포함하고 있어서 상당 기간 표준 역할을 했다. 하지만 컴퓨터가 널리 쓰이게 됨에 따라 그 밖의 언어를 지원해야 할 필요가 점차 늘어났다. **국제 표준화 기구**<sup>ISO, International Standards Organization</sup>는 ISO-646과 ISO-8859를 도입했다. 그리고 일본어, 중국어, 아랍어, 한국어 등의 표준도 생겼다. 이렇게 각기 다른 표준이 존재하는 이유는 비트가 지금보다 더 비싼 시절에 표준이 만들어졌기 때문이다. 그래서 문자를 7비트나 8비트에 욱여넣었다. 비트 가격이 떨어짐에 따라 유니코드<sup>Unicode</sup>라는 새로운 표준이 만들어졌고, 문자에 16비트 코드를 부여했다. 그 후 유니코드는 21비트까지 확장됬다.

### 유니코드 변환 형식 8비트<sup>UTF-8, Unicode Transformation Format-8 bit</sup>
컴퓨터는 7비트값을 처리하도록 설계되지 않았기 때문에 8비트를 사용해 아스키 문자를 저장한다. 과거에 비해 비트가 훨씬 더 저렴해졌지만 8비트만 사용하면 모든 문자를 표현할 수 있는데 굳이 16비트를 사용해 낭비해도 될 만큼 비트가 저렴하지는 않다는 이유로 한 문자를 8비트로 표현한다. 유니코드는 문자 코드에 따라 각기 다른 인코딩을 사용해 이런 문제를 해결한다. **인코딩**<sup>encoding</sup>은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴을 뜻한다. 특히, 켄 톰슨과 롭 파이크가 만든 UTF-8이라는 인코딩 방법이 하위 호환성과 효율성 때문에 가장 널리 쓰이고 있다. UTF-8은 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩 할 때는 추가 공간이 필요하지 않다. 그리고 UTF-8은 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩한다.

## 문자를 사용한 수 표현

### 출력 가능하게 변경한 인코딩<sup>Quoted-Printable encoding</sup>
출력 가능하게 변경한 인코딩은 **쿼티드 프린터블 인코딩** 혹은 **QP 인코딩**이라고도 하는데, 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법이다.

### 베이스64 인코딩<sup>base64 encoding</sup>
QP 인코딩이 잘 작동하기는 하지만 1바이트를 표현하기 위해 3바이트를 사용하기 때문에 아주 비효율적이다. 베이스64 인코딩이 더 효율적인데, 베이스64 인코딩은 3바이트 데이터를 4문자로 표현한다. 3바이트 데이터의 24비트를 네 가지 6비트 덩어리로 나누고, 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현한다. 이 인코딩은 모든 3바이트 조합을 4바이트 조합으로 변환할 수 있다. 하지만 원본 데이터 길이가 3바이트의 배수라는 보장이 없다. **패딩**<sup>padding</sup>문자를 도입해 이런 문제를 해결했다. 원본 데이터가 2바이트 남으면 끝에 **=**를 붙이고, 1바이트 남으면 끝에 **==**를 붙인다.

### URL 인코딩
웹 페이지 URL에서 %26이나 %2F 같은 문자 시퀀스를 본 적이 있을 것이다. 이런 값이 있는 이유는 URL이라는 문맥에서 몇몇 문자가 특별한 의미를 지니기 때문이다. 하지만 이런 특별한 의미를 지니는 문자를 **리터럴**<sup>literal</sup>로 사용할 필요가 있다.(리터럴은 문자 그대로 라는 뜻으로, 특별한 의미 없이 해당 문자 자체를 뜻하는 경우)<br>
URL 인코딩은 **퍼센트 인코딩**<sup>percent-encoding</sup>이라고도 부르는데, % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다.

## 색을 표현하는 방법
컴퓨터 그래픽스<sup>graphics</sup>는 전자 모눈종이에 해당하는 것에 색을 표현하는 점<sup>blob</sup>을 찍어서 그림을 만드는 과정이다. 이때 모눈의 각 격자에 찍는 점을 **그림 원소**<sup>picture element</sup>라고 부르고, 줄여서 **픽셀**<sup>pixel</sup>이라고 부른다.<br>
컴퓨터 모니터는 빨간색, 초록색, 파란색 광선을 섞어서 색을 만들어내는데, 이런 색 표현을 **RGB색 모델**이라고 부른다. 색은 **컬러 큐브**<sup>color cube</sup>(정육면체)라는 것으로 표현할 수 있다. 컬러 큐브에서 각 축은 원색을 표현한다.
값이 0이면 그에 해당하는 원색의 빛을 끈다는 뜻이며, 값이 1이면 해당하는 원색의 빛을 가능한 한 최대 밝기로 켠다는 뜻이다.<br><br>
현대 컴퓨터들은 색을 표현하는 데 24비트를 사용해 1천만에 가장 가까운 2의 제곱수에 해당하는 색을 표현할 수 있다. 이 24비트는 세 가지 8비트 필드로 나뉘며, 각 필드는 세 가지 주요 색을 표현한다.<br>
하지만 현대 컴퓨터들은 24비트 단위로 계산을 수행하도록 설계되지 않았기 때문에 24비트에 가장 가까운 표준 크기인 32비트(워드)에 색을 넣어서 처리하곤 한다. 그렇다면 색을 표현할 때마다 사용하지 않는 비트가 8개 있다는 사실을 알 수 있다. 800만개가 넘는 픽셀을 사용한다면 낭비되는 비트가 너무 많다. 이 남은 8개의 비트를 활용하기 위해 **투명도**<sup>transparency</sup>를 추가했다.

### 색 인코딩
웹에서는 색을 16진 트리플렛<sup>hex triplet</sup>으로 표현한다. 16진 트리플렛은 # 뒤에 여섯 자리 16진 숫자를 추가해 #rrggbb처럼 표현하는 방식이다.
