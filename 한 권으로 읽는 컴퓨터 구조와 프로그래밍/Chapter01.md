# 01. 컴퓨터 내부의 언어 체계

## 언어란 무엇인가
모든 언어의 뜻은 기호의 집합으로 인코딩된다. 하지만 의미를 기호로 인코딩하는 것만으로는 충분하지 않다. 언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 한다.
동일한 기호를 구분할 수 있는 요소는 문맥뿐인데, 언제나 문맥을 명확히 식별할 수 있는 것은 아니다. 컴퓨터 언어에도 마찬가지 문제가 있다.

## 문자 언어
문자 언어는 기호를 나열한 것이다. 기호를 정해진 순서대로 나열하면 단어를 만들 수 있다. 기호나 조합은 무궁무진한 가능성이 있다.
<br><br>
다음과 같은 세 가지 구성요소가 문자 언어의 틀을 이루는데, 컴퓨터 언어에서도 마찬가지다.
- 기호가 들어갈 상자
- 상자에 들어갈 기호
- 상자의 순서

## 비트
자연어에서는 상자를 **문자**라고 부르고 컴퓨터에서는 **비트**라고 부른다. '**비트**'라는 단어는 2진법을 사용한다는 뜻의 '**바이너리**'<sup>binary</sup>와 숫자를 뜻하는 '**디지트**'<sup>digit</sup>가 기묘하게 합쳐진 말이다.
이 결합이 기묘한 이유는 '바이너리'라는 말은 두 가지 부분으로 이뤄진 어떤 대상을 뜻하고, '디지트'라는 말은 일상생활에서 쓰는 10진수를 표현하는 10가지 기호(0~9)를 뜻하기 때문이다.
<br>
비트는 2진법을 사용한다. 이는 비트 상자에는 모스 부호의 점(.)과 선(-)처럼 두 가지 기호 중 하나만 담을 수 있다는 듯이다. 기호라는 개념은 추상적인데 실제로는 기호가 무엇이든 관계없다. 꺼짐/켜짐일 수도 있고, 낮/밤일 수도 있으며, 쌀/보리 게임일 수도 있다. 하지만 중요한 점은 언어는 문맥 없이는 제대로 작동할 수 없다는 점이다.

## 논리 연산
비트 사용법 중 하나는 "날씨가 추운가?", "내 모자를 좋아하나?"와 같이 예/아니요 질문에 대한 답을 표현하는 것이다. 이때 '예'를 **참**<sup>true</sup>이라는 용어로 부르고, '아니요'를 **거짓**<sup>false</sup>이라는 용어로 부른다.
"파티 장소는 어디인가?"와 같은 질문은 예/아니요로 답할 수 없기 때문에 한 비트만으로는 표현할 수 없다.
<br>
자연어에서 여러 예/아니요 구절을 엮어서 한 문장으로 만드는 경우가 자주 있다. "밖에 비가 내리고 있거나 춥다면 코트를 입어라."라고 말할 수 있다. '비가 오고 있는가?'가 참이거나 '추운가?'가 참이거나 다른 비트들이 표현하는 내용으로부터
새로운 비트를 만들어내는 이런 동작을 **논리 연산**<sup>logic operation</sup>이라고 한다.

### 불리언 대수
대수가 수에 대한 연산 규칙의 집합인 것처럼, 1800년대 영국 수학자 조지 불<sup>George Boole</sup>이 만들어낸 **불리언 대수**<sup>Boolean algebra</sup>도 비트에 대해 사용할 수 있는 연산 규칙의 집합이다.
일반 대수와 마찬가지로 결합 법칙, 교환 법칙, 분배 법칙을 불리언 대수에 적용할 수 있다.
<br><br>
기본적인 불리언 연산자는 NOT, AND, OR 세 가지이다. 추가로 XOR이라는 합성 연산이 있다.
- **NOT:** 이 연산은 '논리적 반대'를 의미한다. 예를 들어, 거짓인 비트에 NOT을 하면 참이 되고 참인 비트에 NOT을 하면 거짓이 된다.
- **AND:** 이 연산은 둘 이상의 비트에 작용한다. 2비트 연산인 경우 첫 번째 비트가 참이고 두 번째 비트도 참인 경우에만 결과가 참이 된다. 2비트보다 더 많은 비트에 연산을 적용하는 경우 모든 비트가 참이면 AND 연산의 결과도 참이다.
- **OR:** 이 연산도 둘 이상의 비트에 작용한다. 2비트 연산인 경우 첫 번째 비트가 참이거나 두 번째 비트가 참이면 결과가 참이 된다. 2비트보다 더 많은 비트에 연산을 적용하는 경우 어느 한 비트라도 참이면 OR 연산의 결과도 참이다.
- **XOR:** 이 **배타적**<sup>exclusive</sup> OR의 결과는 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 참이 된다. 즉, 두 값 중 어느 하나가 참이면 XOR도 참이지만 두 값이 모두 참이면 XOR의 결과는 거짓이다. 배타적 OR을 그대로 말로 하면 너무 길기 때문에 줄여서 XOR이라고 부른다.

### 드모르간의 법칙
1800년대 영국 수학자인 오거스터스 드모르간<sup>Augustus De Morgan</sup>은 불리언 대수에 적용할 수 있는 법칙을 추가로 알아냈다. 이 법칙은 발명자의 이름을 따서 **드모르간의 법칙**<sup>De Morgan's law</sup>이라고 알려져 있다. 이 법칙은
**a AND b**라는 연산은 <strong>NOT(NOT a OR NOT b)</strong>와 같다고 말한다. 이 말은 NOT을 사용하면 AND 연산을 OR 연산으로 대신할 수 있고 반대도 가능하다는 뜻이다. 컴퓨터에서 입력을 항상 원하는 형태로 얻을 수만은 없기 때문에 이런 성질이 유용할 때가 있다. 예를 들어, 입력이 '춥다'와 '비가 온다'라는 형식이라면 좋지만, 'NOT 춥다'와 'NOT 비가 온다'라는 형식일 수도 있기 때문이다.

## 정수를 비트로 표현하는 방법

### 양의 정수 표현
- 10진수<br>
우리는 보통 **10진수**<sup>decimal number</sup>체계를 사용하는데, 이는 우리의 손가락과 발가락이 10개씩이기 때문이다. 10진수 체계에서는 10가지 기호인 **숫자**<sup>digit</sup>를 상자에 담을 수 있다. 이때 오른쪽에서 왼쪽으로 상자가 쌓여가며, 각 상자마다 각기 다른 이름이 붙어 있다. 예를 들어 맨 오른쪽에 있는 상자에는 일의 자리, 오른쪽에서 두 번째 상자에는 십의 자리, 세 번째 상자는 백의 자리라는 이름이 붙는다. 각 이름은 10의 거듭제곱에 해당한다. 이 체계는 지수를 적용할 밑<sup>base</sup>으로 10을 사용하기 때문에 **밑이 10**인 시스템이라고 부른다.

- 2진수<br>
10진 숫자 대신 비트를 사용하기 때문에 각 상자에 사용할 수 있는 기호는 1과 0 두 가지밖에 없다. 기호가 10개인 10진수 체계에서 어떤 상자가 표현하는 값은 그 상자에 들어 있는 기호에 해당하는 값에 그 상자의 오른쪽 상자가 차지하는 자릿수에 10을 곱한 값을 곱한 것인데 2진수에서는 기호가 2개이기 때문에 각 상자는 자신의 오른쪽에 있는 상자의 자릿수에 2를 곱한 값의 자리를 표현한다. 각 상자의 자릿수는 2의 거듭제곱이며, 2진수 체계에서는 **2를 밑으로**하는 수 체계다.<br>
2진수에서 가장 오른쪽의 비트를 **가장 작은 유효 비트**<sup>least significant bit</sup>라고 부르고, 가장 왼쪽의 비트를 **가장 큰 유효 비트**<sup>most significant bit</sup>라고 부른다. 가장 작은 유효 비트와 가장 큰 유효 비트를 종종 세 글자 줄임말로 **LSB**와 **MSB**라고 부른다.

5028이라는 숫자를 10진수와 2진수로 표현하면
|$$10^3$$|$$10^2$$|$$10^1$$|$$10^0$$|
|--------|--------|--------|--------|
| 5      | 0      | 2      | 8      |

|$$2^{12}$$|$$2^{11}$$|$$2^{10}$$|$$2^9$$|$$2^8$$|$$2^7$$|$$2^6$$|$$2^5$$|$$2^4$$|$$2^3$$|$$2^2$$|$$2^1$$|$$2^0$$|
|----------|----------|----------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| 1        | 0        | 0        | 1     | 1     | 1     | 0     | 1     | 0     | 0     | 1     | 0     | 0     |

10진수로는 5,028이 네 자리 숫자라고 말할 수 있고 2진수로는 13비트 수가 된다고 말할 수 있다.

### 2진수 덧셈
10진 덧셈에서는 오른쪽(가장 작은 유효 숫자)에서 왼쪽으로 각 자리의 숫자를 서로 더한다. 결과가 9보다 크면 1을 올린다. 마찬가지로, 2진수에서도 각 비트를 LSB에서 MSB쪽으로 더하며 결과가 1보다 크면 1을 다음 자리(왼쪽)로 올린다.<br>
1 + 5 = 6을 2진수 덧셈으로 표현하면 1을 2진수로 표현하면 001이고 5를 2진수로 표현하면 101이다. 2진수 001과 101을 더하려면 가장 오른쪽 LSB부터 더하기를 시작한다. 가장 오른쪽 열의 2진수 1과 1을 더하면 2가 되지만 2진수에서는 2라는 기호가 없다. 대신 2가 실제로 2진수로 10이라는 것을 알고 있다. 따라서 합계로는 0을 표시하고 1을 다음(왼쪽) 숫자로 받아 올린다. 두 수 모두 중간의 비트가 0이기 때문에 여기서는 올려 받은 1만 합계로 적는다. 그 후 가장 왼쪽 열의 숫자를 더한다. 2진수에서 0 더하기 1은 1이다. 이렇게 최종 계산 결과는 110이고 10진수로 표현하면 6이 된다. 그리고 두 비트를 서로 더한 결과는 두 비트를 XOR 한 값고 같고, 올림은 두 비트를 AND 한 값과 같다.
<br>
우리가 접하는 **오버플로**<sup>overflow</sup>란 MSB에서 올림이 발생했다는 뜻이다. 예를 들어, 4비트 덧셈에서 1001(9)과 1000(8)을 더한 결과는 10001(17)이다. 하지만 MSB 왼쪽에 사용할 수 있는 비트가 없기 때문에 결과가 0001(1)이 된다.
컴퓨터에는 <strong>조건 코드(또는 상태코드) 레지스터</strong><sup>condition code register</sup>라는 것이 있어서 몇 가지 정보를 담아둔다. 이런 정보 중에는 **오버플로 비트**<sup>overflow bit</sup>가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. MSB 왼쪽에서 1을 빌려오는 경우는 **언더플로**<sup>underflow</sup>라고 부른다. 이에 해당하는 조건 코드도 컴퓨터에 들어있다.

### 음수 표현
4비트로는 0부터 15까지 16가지 수를 표현할 수 있다. 4비트로 수를 16가지만 표현할 수 있다는 말이 꼭 4비트로는 0부터 15까지만 표현할 수 있다는 뜻은 아니다. 언어는 문맥과 의미를 통해 작용한다. 이 말은 비트들을 해석하는 새로운 문맥을 만들 수 있다는 뜻이기도 하다.

#### 부호와 크기
